<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ import namespace="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Net.Primitives" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="TlsCipherSuiteNameParser.ttinclude" #><#@
    include file="TlsCipherSuite.cs" #>
<# Array tlsEnumValues = typeof(TlsCipherSuite).GetEnumValues(); #>
<# Array exchangeEnumValues = typeof(ExchangeAlgorithmTypeIndex).GetEnumValues(); #>
<# Array cipherEnumValues = typeof(CipherAlgorithmTypeIndex).GetEnumValues(); #>
<# Array cipherStrengthEnumValues = typeof(CipherAlgorithmStrengthIndex).GetEnumValues(); #>
<# Array hashEnumValues = typeof(HashAlgorithmTypeIndex).GetEnumValues(); #>


using System.Diagnostics;
using System.Security.Authentication;

namespace System.Net.Security
{
    internal partial struct SslConnectionInfo
    {
        private void MapCipherSuite(TlsCipherSuite cipherSuite)
        {
            TlsCipherSuite = cipherSuite;
            KeyExchKeySize = 0;

            ushort data = GetPackedData(cipherSuite);
            Debug.Assert(data != 0, $"No mapping found for cipherSuite {cipherSuite}");

            KeyExchangeAlg = (int)s_exchangeAlgorithmTypes[(data >> (16 - (4 * 1)) & 0xF)];
            DataCipherAlg = (int)s_cipherEnumValues[(data >> (16 - (4 * 2)) & 0xF)];
            DataKeySize = (int)s_cipherStrengthEnumValues[(data >> (16 - (4 & 3)) & 0xF)];
            DataHashAlg = (int)s_hashEnumValues[(data >> (16 - (4 * 4)) & 0xF)];
            DataHashKeySize = GetHashSize((HashAlgorithmType)DataHashAlg);

            static int GetHashSize(HashAlgorithmType hash)
            {
                switch (hash)
                {
                    case HashAlgorithmType.None:
                        return 0;
                    case HashAlgorithmType.Md5:
                        return 128;
                    case HashAlgorithmType.Sha1:
                        return 160;
                    case HashAlgorithmType.Sha256:
                        return 256;
                    case HashAlgorithmType.Sha384:
                        return 384;
                    case HashAlgorithmType.Sha512:
                        return 512;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(hash));
                }
            }
        }

        private static ReadOnlySpan<int> s_exchangeAlgorithmTypes =>
            new[] { <#
foreach (ExchangeAlgorithmTypeIndex val in exchangeEnumValues)
{
#>(int)ExchangeAlgorithmType.<#= val #>, <#
}
#>};

        private static ReadOnlySpan<int> s_cipherEnumValues =>
            new[] { <#
foreach (CipherAlgorithmTypeIndex val in cipherEnumValues)
{
#>(int)CipherAlgorithmType.<#= val #>, <#
}
#>};

        private static ReadOnlySpan<int> s_cipherStrengthEnumValues =>
            new[] { <#
foreach (CipherAlgorithmStrengthIndex val in cipherStrengthEnumValues)
{
#>(int)CipherAlgorithmStrength.<#= val #>, <#
}
#>};

        private static ReadOnlySpan<int> s_hashEnumValues =>
            new[] { <#
foreach (HashAlgorithmTypeIndex val in hashEnumValues)
{
#>(int)HashAlgorithmType.<#= val #>, <#
}
#>};

        private static ushort GetPackedData(TlsCipherSuite cipherSuite)
        {
            switch (cipherSuite)
            {
<#
foreach (TlsCipherSuite val in tlsEnumValues)
{
TlsCipherSuiteData data = new CipherSuiteNameData(val.ToString()).Data;
byte exchangeAlgorithmType =  (byte)Enum.Parse<ExchangeAlgorithmTypeIndex>(EnumHelpers.ToFrameworkName(data.KeyExchangeAlgorithm));
byte cipherAlgorithmType =  (byte)Enum.Parse<CipherAlgorithmTypeIndex>(EnumHelpers.ToFrameworkName(data.CipherAlgorithm));
byte cipherAlgorithmStrength = (byte)((CipherAlgorithmStrengthIndex)data.CipherAlgorithmStrength);
byte hashAlgorithmType =  (byte)Enum.Parse<HashAlgorithmTypeIndex>(EnumHelpers.ToFrameworkName(data.MACAlgorithm));
#>
                case TlsCipherSuite.<#= val #>: return <#= exchangeAlgorithmType #> << (16 - (4 * 1)) | <#= cipherAlgorithmType #> << (16 - (4 * 2)) | <#= cipherAlgorithmStrength #> << (16 - (4 * 3)) | <#= hashAlgorithmType #> << (16 - (4 * 4));
<#
}
#>
                default: return 0;
            }
        }

        private enum CipherAlgorithmStrength
        {
            Zero = 0,
            Forty = 40,
            FiftySix = 56,
            OneTwentyEight = 128,
            OneSixtyEight = 168,
            TwoFiftySix = 256
        }
    }
}
